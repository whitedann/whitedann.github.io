<!DOCTYPE html>
<html lang="en">
  <head>
    <title>website</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Text" rel="stylesheet">
  </head>

<body class="content-background">
<a name="home"></a>
<!--top bar -->
<div id="top-bar">
  <!--Navbar-->
  <br>
  <div class="topnav">
    <a href="index.html">home</a>
    <a href="archive.html">archive</a>
    <a href="aboutMe.html">about</a>
    <a href="index.html#contact">contact</a>
  </div>
</div>

<!--New Posts Window-->
<div class="main-content">
	<h1 class="content-heading">Last Circle</h1>
	<div style="text-align: center; margin-bottom: 20px">
		<img src="assets/LastCircleTitle.png" style="width: 500px">

	</div>
	<p>After the school year ended, I decided to make a game over the summer. It presented quite a few interesting programming challenges which I will make note of in this article. I drew all of the art and animations myself which also gave me a lot of respect for just how time-consuming making a game really is. I spent over a dozen hours drawing just a handful of basic sprites!
	</p>
	<p>I ended up using the built-in GUI framework Java.AWT for all the graphics-drawing instead of something more complex like OpenGL. This project was not meant to be flashy, so the .awt framework ended up meeting my needs. Below is a short clip of the game in action. The player controls a blue-turqoise octogon by moving and shooting in the cardinal directions(N, S, W, E). Movement in intercardinal directions(NE,NW,SE,SW) is also possible if the player moves holds down the two buttons at once. The goal is to survive as long as possible. Each enemy destroyed is worth 5 points. 
	</p>
	<div style="text-align: center; margin-bottom: 20px">
	<video src="assets/LastCircleDemo.mp4" style="width: 500px;" loop muted autoplay="true" poster="assets/loading.gif"></video>
	</div>
	<p>The spawn interval begins at 5 seconds and slightly increases as the player's score increases. I wanted to create the feeling that the player was being slowly overwhelmed. I kept track of the enemies in a LinkedList structure and added and removed from it as enemies spawned or were destroyed.
	</p>
	<p>This ended up being an inefficient approach due to the fact that the game was checking was for a ton of collisions at each tick. The game attempts to check for collisions between each creature, wall entity, player and bullet projectile at each tick (60 times per second!). Obviously this was not going to work if I wanted to have dozens of enemies on the field at once, or have the player shoot a lot of projectiles.
	</p>
	<div style="margin-top: 100px; margin-bottom: 100px">
	<h2 style="margin-bottom: 20px">Optimizing Collision Detection</h2>
	<img style="float: left; width: 500px; margin-right: 25px" src="assets/WorldGrid1.png">
	<p>
	There are ways to optimize collision detection. I ended up breaking the world up into small square regions, and only perform collision checks on entities that exist in the the same regions: 
	</p>
	<p>In this diagram we would first sort the four entities into seperate lists for each region, then we would go through and only check for collisions for each region. For region (0,0) that would be entities A, B, and D. For region (0,1), that would be entities B, C, and D.
	</p>
	<p>With this method, we eliminate a lot of checks between objects that are too far apart to collide. It also gives us a nice way to track the presence of entities in any particular area on the game field (I used this data to prevent enemies from spawning on top of each other)
	</p>
	<p>
	At a minimum, we are still going to have to iterate through all of the entities in the game i.e. If there are N entities, we are going to have to sort N items. Afterward we perform a collision check on all neighboring entities. Worst case, this still represents O(N^2) complexity. However, if we prevent enemies from moving thorugh each other, the maximum amount of compares is actually quite small. I used a region size of 64x64 pixels. Since the sizes of my entities were 16x16, 32x32 and 64x64 pixels, it was impossible for more than 8 enemies to occupy the same cell. 
	</p>
	<p>
	I eventually found out that there other better ways to check for collisions between objects. Check out this video that uses the quad tree data structure to 
	</div>
	<div style="margin-top: 100px; margin-bottom: 100px;">
	<h3 style="margin-bottom: 20px">Calculating Collisions Between Circlular Entities</h3>
	<img style="float:left; width: 300px; margin-right: 20px" src="assets/eeCollision.png">
	<p>
	Most of the entities in this game were some form of circle, which is great because checking for collisions between entities is simple. If two circles A and B have radii R and r respectively then all we have to do is check that their relative separation distance, S, is greater than the sum of their two radii. In other words,  
	</p>
	<a class="equation-center" href="http://www.codecogs.com/eqnedit.php?latex=\texttt{if}&space;(R&space;&plus;&space;r&space;>&space;\sqrt{(x_{B}-x_{A})^{2}&plus;(y_{B}-y_{A})^{2}})\rightarrow&space;\textup{Collision&space;between&space;A&space;and&space;B}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\texttt{if}&space;(R&space;&plus;&space;r&space;<&space;\sqrt{(x_{B}-x_{A})^{2}&plus;(y_{B}-y_{A})^{2}})\rightarrow&space;\textup{Collision&space;between&space;A&space;and&space;B}" title="\texttt{if} (R + r < \sqrt{(x_{B}-x_{A})^{2}+(y_{B}-y_{A})^{2}})\rightarrow \textup{Collision between A and B}" style="margin-bottom: 10px; width: 450px"/></a>
	<a class="equation-center" href="http://www.codecogs.com/eqnedit.php?latex=\texttt{else}\rightarrow&space;\textup{No&space;Collision&space;between&space;A&space;and&space;B}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\texttt{else}\rightarrow&space;\textup{No&space;Collision&space;between&space;A&space;and&space;B}" title="\texttt{else}\rightarrow \textup{No Collision between A and B}" style="margin-bottom: 20px; width: 250px;"/></a>		
	<p>We can optimize this calculation by simply squaring both sides of the equation. This way, we avoid having to use the more expensive square root operation</p>
	</div>
	<div style="margin-top: 100px; margin-bottom: 100px">
	<h3>Calculating Collisions Between Rectangular and Circular Objects</h3>
	<div style="margin-top: 30px; margin-bottom: 30px">
	<video style="margin-left: 15px; float: right; width: 200px; height: 200px" src="assets/collisionDemo.mp4" muted loop autoplay="true"></video>
	<p>
	Calculating collisions between circles and rectanlge is a bit more complicated. With circles, the bounds of the shape are constant; wherever you are arond the circle, the distance to the center is always the same (because the radius is a constant). 
	</p>
	<p>With a rectangle, the distance from the center to the edge of the rectangle depends on your position relative to the center, so we have to do a little more math. The function below descibes a way of checking for a collision between a rectangular shape(with known height, width, position) and a circular entity(with known radius and position). 
	</p>
	</div>
	<pre style="width: 700px; font-size: 12px; margin: 20px;" class="code-box2">


    public boolean entityIntersectsRect(Rectanlge rect, Entity e){
	    double circleDistanceX = Math.abs(e.getCenterX() - rect.getCenterX()); 
	    double circleDistanceY = Math.abs(e.getCenterY() - rect.getCenterY());
	    
	    if(circleDistanceX &gt (e.getRadius() + rect.getWidth()/2)) {return false;}
	    if(circleDistanceY &gt (e.getRadius() + rect.getHeight()/2)) {return false;}

	    if(circleDistanceX &lt (e.getRadius() + rect.getWidth()/2)) {return true;}
	    if(circleDistanceY &lt (e.getRadius() + rect.getHeight()/2)) {return true;}

	    cornerSquareDistance = ((circleDistanceX - rect.getWidth()/2)^2 + 
	    		            (circleDistanceY - rect.getHeight()/2)^2)
	    return (cornerSquareDistance &lt= e.getRadius()^2);

	</pre>
	<p>Here's how it works:</p>
       	<img style="float:right; width: 300px; margin: 20px; border: 1px solid black" src="assets/collisionDiagram.jpg">
	<ul style="list-style: none;">
		<li>
			<p>
			1. The first two lines calculate the distance between the center of the circle and center of the rectangle in component x, y form. 
			</p>
		</li>
		<li>
			<p>
			2.
                         The second two lines check for the "easy case" where a collision is impossible because the relative distance is greater than the radius of the circle and the maximum bounds of the rectangle. In the diagram, the corresponds to the circle being in the green region. 
                            </p>
		</li>
		<li>
			<p>2.
	The next two lines check for the easy case where a collision is guranteeed because the rectangles bounds are greater than the separation distance. This corresponds to the grey and orange sections on the diagram.
	</p>

		</li>
		<li>
			3. The last lines compute the more difficult case where the circle can intersect the corner of the rectanlge. It accomplishes this by calculating the distance of the center of the circle to the edge of the rectangle and then comparing this to the radius of the circle. If the radius is larger than this distance, then the function returns false corresponding to circles in the red region, or true for circles who intersect the white region.
		</li>
	</ul>
	</div>
	<h3 style="margin-bottom: 20px">Animations, Sprites</h3>
	<p>
	The game animates entities by looping through an array of buffered images for each tick. By default, objects loop through this array indefinitely until some flag is given. For example, the player death flag switches the player animation to a death animation. For the sake of convenience, animations are composed of images that exist on larger image sheets. At run time, the game loads these sheets and crops them into their individual form. Here are some spritesheets for a some enemies in the game, and their animations.
	</p>
	<div style="text-align: center">
	<div style="display: inline-block">
	<figure style="padding: 5px; text-align: center">
		<img src="assets/pinwheel.png">
		<img src="assets/pinwheel.gif">
		<figcaption style="font-size: 13px; margin: 15px">SpriteSheet for PinWheel Enemy Movement</figcaption>
	</figure>
	</div>
	<div style="display: inline-block">
	<figure style="padding: 5px; text-align: center">
		<img src="assets/bigDeath.png">
		<img src="assets/bigDeath.gif">
		<figcaption style="font-size: 13px; margin: 15px">SpriteSheet for Larger Enemy Death</figcaption>
	</figure>
	</div>
	<div style="display: inline-block">
	<figure style="padding: 5px; text-align: center">
		<img src="assets/turretExplosion.png">
		<img src="assets/turretExplosion.gif">
		<figcaption style="font-size: 13px; margin: 15px">SpriteSheet for Player Death</figcaption>
	</figure>
	</div>                                                                                                    	
	</div>
	<p>
	The complete source code as well as a mac-friendly executable jar is available <a href="https://github.com/whitedann/LastCircle">here</a>. I'll eventually upload a windows-friendly version, but if you want it badly, go ahead and send me an email.
	</p>
</div>

<div class="footer-container">
<div class="upper-footer">
  <div>                                                                                                                         
	<p style="font-family: 'Oswald', sans-serif; margin: 0">AROUND THE WEB</p>
	<a href="https://github.com/whitedann"><img class="botbutton" src="assets/github.svg"></a>
	<a href="https://www.linkedin.com/in/daniel-white-76434a66/"><img class="botbutton" src="assets/linkedin_circle.png"></a>
  </div>
</div>
<div class="lower-footer">
  <a style="text-decoration: none; color: white" href="index.html#home">top</a>
</div>
</div>
</body>
