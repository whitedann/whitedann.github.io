<!DOCTYPE html>
<html lang="en">
  <head>
    <title>website</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Text" rel="stylesheet">
  </head>

<body class="content-background">
<a name="home"></a>
<!--top bar -->
<div id="top-bar">
  <!--Navbar-->
  <br>
  <div class="topnav">
    <a href="index.html">home</a>
    <a href="archive.html">archive</a>
    <a href="aboutMe.html">about</a>
    <a href="index.html#contact">contact</a>
  </div>
</div>

<!--New Posts Window-->
<div class="main-content">
	<h1 class="content-heading">Last Circle</h1>
	<p>After the school year ended, I decided to make a game over the summer. It presented quite a few interesting programming challenges which I will make note of in this article. I also drew all of the art and animations myself which gave me a lot of respect for just how time-consuming making game assets is (I spent over a dozen hours drawing and it is a pretty small game!). 
	</p>
	<p>I ended up using the built-in GUI framework Java.AWT for all the graphics-drawing instead of something more complex like OpenGL. This project was not meant to be flashy, so the .awt framework ended up meeting my needs. Below is a short clip of the game in action. The player controls a blue-turqoise octogon by moving and shooting in the cardinal directions(N, S, W, E). Movement in intercardinal directions(NE,NW,SE,SW) is also possible if the player moves holds down the two buttons at once. The goal is to survive as long as possible. Each enemy destroyed is worth 5 points. 
	</p>
	<div style="width: 50%; margin-left: auto; margin-right: auto">
		<video src="assets/LastCircleDemo.mp4" style="width: 500px" loop muted autoplay="true" poster="assets/linkedin_circle.png"></video>
	</div>
	<p>The spawn interval begins at 5 seconds and slightly increases as the player's score increases. I wanted to create the feeling that the player was being slowly overwhelmed. I kept track of the enemies in a list structure and added and removed from it as enemies spawned or were destroyed.
	</p>
	<p>This ended up being an inefficient approach due to the fact that the game was checking was for a ton of collisions at each tick. The game attempts to check for collisions between each creature, wall entity, player and bullet projectile at each tick (60 times per second!). Obviously this was not going to work if I wanted to have dozens of enemies on the field at once, or have the player shoot a lot of projectiles.
	</p>
	<h2>Optimizing Collision Detection</h2>
	<p>
	A cool way to optimize this problem is to break the world up into small square regions, and only perform collision checks on entities that exist in the the same regions: 
	</p>
	<img style="float: left; width: 50%; margin-right: 25px" src="assets/WorldGrid1.png">
	<p>In this diagram we would first sort the four entities into seperate lists for each region, then we would go through and only check for collisions for each region. For region (0,0) that would be entities A, B, and D. For region (0,1), that would be entities B, C, and D.
	<p>With this method, we eliminate a lot of checks between objects that are too far apart to collide. It also gives us a nice way to track the presence of entities in any particular area on the game field (I used this data to prevent enemies from spawning on top of each other)
	</p>
	<p>
	At a minimum, we are still going to have to iterate through all of the entities in the game i.e. If there are N entities, we are going to have to sort N items. Afterward we perform a collision check on all neighboring entities. Worst case, this still represents O(N^2) complexity. However, if we prevent enemies from moving thorugh each other, the maximum amount of compares is actually quite small. I used a region size of 64x64 pixels. Since the sizes of my entities were 16x16, 32x32 and 64x64 pixels, it was impossible for more than 8 enemies to occupy the same cell. 
	</p>
	<div style="margin: 20px">
	<h3>Calculating Collisions Between Circlular Entities</h3>
	<img style="float:left; width: 30%; margin-right: 20px" src="assets/eeCollision.png">
	<p>
	Most of the entities in this game were some form of circle, which is great because checking for collisions between entities is simple. If two circles A and B have radii R and r respectively then all we have to do is check that their relative separation distance, S, is greater than the sum of their two radii. In other words,  
	</p>
	<a href="http://www.codecogs.com/eqnedit.php?latex=\texttt{if}&space;(R&space;&plus;&space;r&space;>&space;\sqrt{(x_{B}-x_{A})^{2}&plus;(y_{B}-y_{A})^{2}})\rightarrow&space;\textup{Collision&space;between&space;A&space;and&space;B}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\texttt{if}&space;(R&space;&plus;&space;r&space;>&space;\sqrt{(x_{B}-x_{A})^{2}&plus;(y_{B}-y_{A})^{2}})\rightarrow&space;\textup{Collision&space;between&space;A&space;and&space;B}" title="\texttt{if} (R + r > \sqrt{(x_{B}-x_{A})^{2}+(y_{B}-y_{A})^{2}})\rightarrow \textup{Collision between A and B}" style="margin-bottom: 10px; width: 450px"/></a>
	<a href="http://www.codecogs.com/eqnedit.php?latex=\texttt{else}\rightarrow&space;\textup{No&space;Collision&space;between&space;A&space;and&space;B}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\texttt{else}\rightarrow&space;\textup{No&space;Collision&space;between&space;A&space;and&space;B}" title="\texttt{else}\rightarrow \textup{No Collision between A and B}" style="margin-bottom: 20px; width: 250px"/></a>		
	<p>We can optimize this calculation by simply squaring both sides of the equation. This way, we don't have to perform an expensive square root operation</p>
	</div>
	<div style="margon: 20px">
	<h3>Calculating Collisions Between Rectangular and Circular Objects</h3>
	<img style="float:left; width: 30%; margin-right: 20px" src="assets/collisionDiagram.jpg">
	<p>
	Calculating collisions between circles and rectanlge is a bit more complicated. There are three cases that must be considered when checking for collisions.
	</p>
	<ul style="list-style: none;">
		<li >
			1.  
		</li>
		<li>
			2.
		</li>
		<li>
			3.
		</li>
	</ul>
	</div>
</div>

<div class="footer-container">
<div class="upper-footer">
  <div>                                                                                                                         
	<p style="font-family: 'Oswald', sans-serif; margin: 0">AROUND THE WEB</p>
	<a href="https://github.com/whitedann"><img class="botbutton" src="assets/github.svg"></a>
	<a href="https://www.linkedin.com/in/daniel-white-76434a66/"><img class="botbutton" src="assets/linkedin_circle.png"></a>
  </div>
</div>
<div class="lower-footer">
  <a style="text-decoration: none; color: white" href="index.html#home">top</a>
</div>
</div>
</body>
