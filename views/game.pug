extends layout

block content
  .col-md-9
    h1 Last Circle
    hr.bg-white
    .text-center.py-3
      img(width='60%' src="assets/LastCircleTitle.png")
    p I spent a couple months trying to make a game this summer. It presented quite a few interesting challenges and in hindsight there are a lot of things I would have done differently. Overall, I am relatively pleased with the way it turned out. 
    p I began with the default java.awt API used to open windows and draw shapes to the screen. Eventually I had a working prototype for the game and I decided not to enlist the help of a more robust framework like OpenGL or the like; This project was not meant to be flashy, so the .awt framework ended up meeting my needs. Below is a short clip of the game in action. The player controls a blue-turqoise octogon by moving and shooting in the cardinal directions(N, S, W, E). Movement in intercardinal directions(NE,NW,SE,SW) is also possible if the player moves holds down the two buttons at once. The goal is to survive as long as possible. Each enemy destroyed is worth 5 points. 
    .text-center.pb-3
      video(width='60%' autoplay, loop, muted).float-left.pr-2
        source(src="assets/LastCircleDemo2.mp4", type="video/mp4")
    p The spawn interval begins at 5 seconds and slightly increases as the player's score increases. I wanted to create the feeling that the player was being slowly overwhelmed. I kept track of the enemies in a LinkedList structure and added and removed from it as enemies spawned or were destroyed.
    p This ended up being an inefficient approach due to the fact that the game was checking was for a ton of collisions at each tick. The game attempts to check for collisions between each creature, wall entity, player and bullet projectile at each tick (60 times per second). Obviously this was not going to work if I wanted to have dozens of enemies on the field at once, or have the player shoot a lot of projectiles.
    h2 Collision detection
    p To make the game run faster, I broke up the world into small square regions, so that I only needed to perform collision checks on entities that were in the the same "region": 
    img(width='40%' src="assets/WorldGrid1.png").float-left.pr-2
    p In this diagram we would first sort the four entities into seperate lists for each region, then we would go through and only check for collisions for each region. For region (0,0) that would be entities A, B, and D. For region (0,1), that would be entities B, C, and D.
    p With this method, we eliminate a lot of checks between objects that are too far apart to collide. It also gives us a nice way to track the presence of entities in any particular area on the game field (I used this data to prevent enemies from spawning on top of each other).
    p At a minimum, we are still going to have to iterate through all of the entities in the game i.e. If there are N entities, we are going to have to check N items against N other entities for collisions. This overhead can add up pretty quick and drag down the frame rate. If we prevent enemies from moving thorugh each other, the maximum amount of collision checks for any entity is limited to the number of entities that can fit inside of a cell. I used a region size of 64x64 pixels, and since the sizes of my entities were 16x16, 32x32 and 64x64 pixels, it was impossible for more than 8 enemies to occupy the same cell. Still, this is not really very ideal. It turns out that there are better ways to detect collisions between particles in a 2D space. Check out this video that keeps track of entites inside of a quadtree data structure (rather than a List) to optimize collision detection between particles. 
    h4 Calculating Collisions Between Circular Entities
    p What is the math that we actually use to determine if two entities are colliding? It depends on the shape of the entiies. Most of the entities in this game were some form of circle, which is great because checking for collisions between entities is simple. If two circles A and B have radii R and r respectively then all we have to do is check that their relative separation distance, S, is greater than the sum of their two radii. 
    p We can optimize this calculation by simply squaring both sides of the equation. This way, we avoid having to use the more expensive square root operation.
    h4 Calculating Collisions Between Rectangular And Circular Entities
    video(width='30%' autoplay, loop, muted).float-right.pr-2
      source(src="assets/collisionDemo.mp4", type="video/mp4")
    p Calculating collisions between circles and rectanlge is a bit more complicated. With circles, the bounds of the shape are constant; wherever you are arond the circle, the distance to the center is always the same (because the radius is a constant). 
    p With a rectangle, the distance from the center to the edge of the rectangle depends on your position relative to the center, so we have to do a little more math. The function below descibes a way of checking for a collision between a rectangular shape(with known height, width, position) and a circular entity(with known radius and position). 



    
  
    
