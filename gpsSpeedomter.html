<!DOCTYPE html>
<html lang="en">
  <head>
    <title>website</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Text" rel="stylesheet">
  </head>

<body class="content-background">
<a name="home"></a>
<!--top bar -->
<div id="top-bar">
 	<br> 
	<!--Navbar-->
  <div class="topnav">
    <a href="index.html">home</a>
    <a href="archive.html">archive</a>
    <a href="aboutMe.html">ask</a>
  </div>
  <br>
</div>

<div class="main-content">
    <h1 class = "content-heading">GPS/Arduino Powered Speedometer</h1>
    <p>
    <img class="content-image-small" src="assets/gpsPic.JPG">
    You can easily interface a GPS chip like this one with an an Arduino micro-controller and make some pretty cool projects. I decided to make a simple speedometer/odometer for my bike. For this to work, we need to retrieve the relevant data from the GPS module, then process it using the Arduino before outputting it to the LCD screen. The device will also need to be powered by a battery so we can carry it around freely.
    <br>
    <br>
    How do we get output from the module? The receiver chip has two serial pins which send and receive data, both of which are connected to ports on the Arduino that have been programmed to send(TX) and receive(RX) serial data. By default, the module outputs data in NMEA format. NMEA data consists of strings of sentences, the first word of which defines the values of the rest of the string. Here is an example of a single sentence of NMEA data:
    <br>
    <br>
    <span class="code-box2">
    $GPRMC,092751.000,A,03424.698,N,11951.976,W,0.06,31.66,280511,003.1,,,A*45
    </span>
    <br>
    <br>
    Where:
    <br>
    <pre>
      GPRMC         indicates the type of output sentence (stands for GP Recommended Minimum)
      092751        is the time taken at 9:27:51 UTC
      A             Status = Active (Alt V = Void)
      03424.698,N   Latitude 34 degrees 24.698 minutes North
      11951.976,W   Longitude 119 degrees 51.976 Minutes West
      0.06          Ground speed in knots
      084.4         Track angle in degrees
      280511        Date 28th of May 2011
      003.1         Magnetic variation
      A*45          Checksum
    </pre>
    </p>
    <p>
    In this case, we are only really interested in the speed data which lies behind the 7th comma in the string. We can write some code
    to parse the string with this in mind. Pretty simple!
    <pre class="code-box2">/*parses through NMEA string using commas as delimiters */

void dataParse(int section) {    
  char nextChar;                                  
  int commas = 0;
  resetReturn();                                      /*Reset method*/
  for (int x = 0; x <= dataStr.length(); x++) { 
    nextChar = dataStr.charAt(x);
    if (nextChar == ',') {                            /*If comma is found, increment comma counter and continue*/
     commas++;
     continue;
    }
    if (commas == section) {                          /*"section" refers will be equal to 7 for our purposes. If commas = 7, we have arrived at the speed data */
  returnStr.concat(nextChar);
    }
    else if (commas > section) {                      /*After we have passed the speed data, we start over on the next string*/
 break;
    }
  }  
}</pre>
    
    Following that, the arduino can do a bit of formatting and output this to our LCD screen. I will admit that the code that got this to work is pretty messy (I wrote it with basically no programming experience when I was in college), but it gets the job done. You can find a link to the entirety of the soruce code <a href="https://github.com/whitedann/GPS1">HERE</a>. It isn't really very complicated, and I imagine its something very similiar to what you would use to get an arduino talking to other more modern gps modules.
    <br>
    <br>
    Additionally, here is a basic schematic for how I hooked everything up. Line crossing do not indicate connections. ONLY the dots do...
    <br>
    <br>
    <img class ="content-image-whole" src="assets/gpsSchematic.png">
    <br>
    <br>
    I'll add that there are a few problems with the project that I never had time to solve. Maybe you may want to?
    <br>
    <br>
    <h5>1. What to do when the module isn't communicating with satellites.</h5><p>When the module gains power, it takes a little while to start outputting valid strings. This is because it takes time for it to acquire enough satellites to construct its data string. During this start-up time, nothing about our code works, because it is trying to parse a string that is essentially nothing but commas. Once the module starts outputting valid strings, the LCD starts showing us what we want. There is probably a more elegant way to check to see if the module is properly connected to enough satellites. Maybe something on the display to indicate it is still connecting?</p>
    <h5>2. Power consumption</h5><p>On a brand new 9V battery, this device dies after only about 4 hours of use. Yikes! I think you could probably make this last a lot longer if you put a resister on the ground pin of both the arduino and the LCD screen. 4 hours is not really very useful. Also a button which could turn off the device while saving odometer data might be good too.</p>
    <h5>3. Small speed problems</h5><p>The chip was basically accurate in its output, but sometimes I noticed that it was giving bad readings. I noticed this especially when I was standing still and it was reading a small .5 mile-per-hour speed! This caused the odometer to gain miles even when I tinkering with it in my chair. Not good. My quick fix was to define a minimum speed which needed to be exceeded before it registered any speed at all. I chose .75 MPH. Perhaps there is a better way to deal with this.</p>
    <h5>4. Housing/Portability</h5><p>I strapped this onto my bike with zip ties and a duct tape. To be fair, it worked everyday for the whole summer! But an actual printed circuit board inside of a protective case was badly needed.</p>

    <h5>Bonus:</h5>
    <p>Here is a really bad video of the speedometer working in action! (the odometer hadn't been implemented yet). Here see me gingerly driving down an empty road while trying to hold my camera phone steady. No one was hurt I promise!</p>
    <div style="margin-left:auto;margin-right:auto"><iframe width="420" height="315" src="https://youtube.com/embed/2ShgyZf24lY"></iframe></div>
    <p>Note: in this video the refresh rate was set to 1Hertz</p>
    
    
</div>

<div class="footer-container">
<div class="upper-footer">
  <div>
  <p style="font-family: 'Oswald', sans-serif; margin: 0">AROUND THE WEB</p>
  <a href="https://github.com/whitedann"><img class="botbutton" src="assets/github.svg"></a>
  <a href="https://www.linkedin.com/in/daniel-white-76434a66/"><img class="botbutton" src="assets/linkedin_circle.png"></a>
  </div>
</div>
<div class="lower-footer">
  <a style="text-decoration: none; color: white" href="index.html#home">top</a>
</div>
</div>

</body>

</html>
