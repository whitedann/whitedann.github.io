<!DOCTYPE html>
<html lang="en">
  <head>
    <title>website</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Text" rel="stylesheet">
  </head>

<body>
<a name="home"></a>
<!--top bar -->
<div id="top-bar">
  <h1>d.white</h1>
  <!--Navbar-->
  <div class="topnav">
    <a href="index.html">home</a>
    <a href="#archive">archive</a>
    <a href="#about">about</a>
    <a href="#contact">contact</a>
  </div>
  <br>
</div>

<div class="main-content">
    <h1 class = "content-heading">Physics with Python</h1>
    <video src="testdubpend.mp4" style="margin-left:auto; margin-right:auto; width: 600px"controls></video>
    <p>
    In this post, I will explain how I animated some simple physical systems using the python plotting library matplotlib.
    To start, each system use a class which contains:
    <ol>
	    <li>A method which defines and returns the differential equations describing the system's motion.</li>
	    <li>A method which solves the system of equations and returns the coordinates of each mass for each "step" in time.</li>
	    <li>An initial state for the system, as well as other defined constants needed for each system.</li>
    </ol>
    I wrote another post showing how to produce the equations of motion for each case here.
    </p>
    <h2>Single Pendulum</h2>
    <p>
    We want to draw (x,y) as a function time using from the system of equations
    <br>
    <br>
    <img class="equation-center" src="http://latex.codecogs.com/svg.latex?\begin{pmatrix} z_{1} = \dot{\theta}\\ z_{2} = -\frac{g}{l}sin(\theta) \end{pmatrix}" border="0"/>
    <br>
    We use the built-in function odeint from the SciPy library to solve for the values of theta as a function of time. We need to supply odeint with the function, the initial state and the time axis as paramters. So, we will initialize the pendulum object with init_state at 35 degrees and a time interval of .025 from 0 to 50. This produces 2000 frames which will be rendered at 40fps over 50 seconds.
    </p>
    <p>
    We can also use this time to define the length of the Pendulum L, and the acceleration due to gravity, g.
    </p>
    <pre class="code-box2">
    import numpy as np
    from matplotlib import pyplot as plt
    from scipy.integrate import odeint
    import matplotlib.animation as animation

class Pendulum():

    def __init__(self,
                 g = 9.8,
                 L = 2.0):

	"""init_state has the form [theta, thetaDot]"""
        self.init_state = [np.radians(35.0), 0]
        self.time = np.arange(0, 50.0, 0.025) 
        self.g = g
        self.L = L
	</pre>
	<p>
	Now let's create a callable function for odeint that returns the system we want to intergrate, and initialize it to the initial state that we pass to odeint (this will be init_state).
	</p>
	<pre class="code-box2">
    def equation(self, y0,t):

        theta, thetaDot = y0
        f = [thetaDot, -(self.g/self.L)*sin(theta)]
        return f
	</pre>
	<p>
	Then let's create a function which perfroms the odeint call, and then converts the data into (x,y) coordinates so that we can more easily plot it.

	<pre class="code-box2">
    def solve_ODE(self):
       
        self.state = odeint(self.equation, self.init_state, self.time)
        x1 = sin(self.state[:, 0])*self.L
        y1 = -1*cos(self.state[:, 0])*self.L

        return x1, y1
	</pre>
	<p>
	By calling the solve_ODE method on a pendulum object, we can create the data we need to animate the pendulum and save it as an array.
	</p>
	<pre class="code-box2">
	pend = Pendulum()
	singlePendulumData = np.array(pend.solve_ODE())
	</pre>
	<p>

	<p>
	<pre class="code-box2">

    fig = plt.figure()
    ax = fig.add_subplot(111)
    line, = ax.plot([],[])
	</pre>
    </p>
	<p>
	We start by creating a figure object and putting a subplot within it "ax" which takes up the whole window. Then we initialize a line object to represent the pendulum. The line object is just a set of tuple coordinates with the form line[xdata, ydata].
	<br>
	<br>
	The method we will use to animate our data, FuncAnimation, takes a figure and repeatedly calls an "animate" function over and over again for the entered number of frames. Finally, we call the animation function putting in all the pieces:
	</p>
	<pre class="code-box2">
def animateSinglePendulum(num, data, line):
    line.set_data([0,data[0,num]], [0,data[1,num]])
    return line

ani = animation.FuncAnimation(fig, animateSinglePendulum, 
	interval=1, frames=2000, fargs=(singlePendulumData, line),
	init_func=initSinglePendulumWindow, repeat=False)
	</pre>
	<p>
	I plotted the pendulums for the two cases discussed here, and added a few bells and whistles to compare the accuracy simulation using the small angle approximation and the one that doesn't.
	</p>
	<br>
	<div style="margin:auto; text-align:center">
		<div style="margin: auto; width: 49%; display:inline-block">
			<video src="assets/sPend35.mp4" style="width: 100%; margin-right: auto; margin-left:auto" loop muted autoplay="true"></video>
			<p style="font-size: 10px">Initial Angle = 35 degrees</p>
		</div>
		<div style="margin: auto; width: 49%; display:inline-block">
			<video src="assets/sPend15.mp4" style="width: 100%; margin-right: auto; margin-left:auto" muted loop autoplay="true"></video>
			<p style="font-size: 10px">Initial Angle = 15 degrees</p>
		</div>
	</div>
	The red pendulum represents the less accurate model using the approximation and the blue is the the more accurate model. I added a plot on the top that shows you a comparasion of the theta versus time for each of the two simulations, as well showing the phase difference (how delayed the inaccurate model is at every moment in time).
	</p>
</div>

<div class="upper-footer">
  <div>
  <p style="font-family: 'Oswald', sans-serif; margin: 0">AROUND THE WEB</p>
  <a href="https://github.com/whitedann"><img class="botbutton" src="assets/github.svg"></a>
  <a href="https://www.linkedin.com/in/daniel-white-76434a66/"><img class="botbutton" src="assets/linkedin_circle.png"></a>
  </div>
</div>
<div class="lower-footer">
  <a style="text-decoration: none; color: white" href="index.html#home">top</a>
</div>

</body>

</html>
