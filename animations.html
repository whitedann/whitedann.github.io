<!DOCTYPE html>
<html lang="en">
  <head>
    <title>website</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Text" rel="stylesheet">
  </head>

<body>
<a name="home"></a>
<!--top bar -->
<div id="top-bar">
  <h1>d.white</h1>
  <!--Navbar-->
  <div class="topnav">
    <a href="index.html">home</a>
    <a href="#archive">archive</a>
    <a href="#about">about</a>
    <a href="#contact">contact</a>
  </div>
  <br>
</div>

<div class="main-content">
    <h1 class = "content-heading">Pendulum Simulations with Python</h1>
    <div style="margin-right:auto;margin-left:auto;width:80%; text-align:center">
    <video src="testdubpend.mp4" style="margin-left:auto; margin-right:auto; width: 50%" muted autoplay></video>
    </div>
    <br>
    <p>
    In this post, I will explain how I animated some simple physical systems using the python plotting library matplotlib.
    To start, each system use a class which contains:
    <ol>
	    <li>A method which defines and returns the differential equations describing the system's motion.</li>
	    <li>A method which solves the system of equations and returns the coordinates of each mass for each "step" in time.</li>
	    <li>An initial state for the system, as well as other defined constants needed for each system.</li>
    </ol>
    I wrote another post showing how to produce the equations of motion for each case here.
    </p>
    <h2>Single Pendulum</h2>
    <p>
    We want to draw (x,y) as a function time using from the system of equations:
    <br>
    <br>
    <br>
 	<img class="equation-center" src="http://latex.codecogs.com/svg.latex?\dot{\vec{z}}=\begin{pmatrix}\dot{\theta}\\-\frac{g}{l}\sin \theta\end{pmatrix}" border="0"/>
    <br>
    <br>
    We use the built-in function odeint from the SciPy library to solve for the values of theta as a function of time. We need to supply odeint with the function, the initial state and the time axis as paramters. So, we will initialize the pendulum object with init_state at 35 degrees and a time interval of .025 from 0 to 50. This produces 2000 frames which will be rendered at 40fps over 50 seconds.
    </p>
    <p>
    We can also use this time to define the length of the Pendulum L, and the acceleration due to gravity, g.
    </p>
    <pre class="code-box2">
    import numpy as np
    from matplotlib import pyplot as plt
    from scipy.integrate import odeint
    import matplotlib.animation as animation

class Pendulum():

    def __init__(self,
                 g = 9.8,
                 L = 2.0):

	"""init_state has the form [theta, thetaDot]"""
        self.init_state = [np.radians(35.0), 0]
        self.time = np.arange(0, 50.0, 0.025) 
        self.g = g
        self.L = L
	</pre>
	<p>
	Now let's create a callable function for odeint that returns the system we want to intergrate, and initialize it to the initial state that we pass to odeint (this will be init_state).
	</p>
	<pre class="code-box2">
    def equation(self, y0,t):

        theta, thetaDot = y0
        f = [thetaDot, -(self.g/self.L)*sin(theta)]
        return f
	</pre>
	<p>
	Then let's create a function which perfroms the odeint call, and then converts the data into (x,y) coordinates so that we can more easily plot it.

	<pre class="code-box2">
    def solve_ODE(self):
       
        self.state = odeint(self.equation, self.init_state, self.time)
        x1 = sin(self.state[:, 0])*self.L
        y1 = -1*cos(self.state[:, 0])*self.L

        return x1, y1
	</pre>
	<p>
	By calling the solve_ODE method on a pendulum object, we can create the data we need to animate the pendulum and save it as an array.
	</p>
	<pre class="code-box2">
	pend = Pendulum()
	singlePendulumData = np.array(pend.solve_ODE())
	</pre>
	<p>

	<p>
	<pre class="code-box2">

    fig = plt.figure()
    ax = fig.add_subplot(111)
    line, = ax.plot([],[])
	</pre>
    </p>
	<p>
	We start by creating a figure object and putting a subplot within it "ax" which takes up the whole window. Then we initialize a line object to represent the pendulum. The line object is just a set of tuple coordinates with the form line[xdata, ydata].
	<br>
	<br>
	The method we will use to animate our data, FuncAnimation, takes a figure and repeatedly calls an "animate" function over and over again for the entered number of frames. Finally, we call the animation function putting in all the pieces:
	</p>
	<pre class="code-box2">
def animateSinglePendulum(num, data, line):
    line.set_data([0,data[0,num]], [0,data[1,num]])
    return line

ani = animation.FuncAnimation(fig, animateSinglePendulum, 
	interval=1, frames=2000, fargs=(singlePendulumData, line),
	init_func=initSinglePendulumWindow, repeat=False)
	</pre>
	<p>
	I plotted the pendulums for the two cases discussed here, and added a few bells and whistles to compare the accuracy simulation using the small angle approximation and the one that doesn't.
	</p>
	<br>
	<div style="margin:auto; text-align:center">
		<div style="margin: auto; width: 49%; display:inline-block">
			<p style="font-size: 15px">Initial Angle = 15 degrees</p>
			<video src="assets/sPend15.mp4" style="width: 100%; margin-right: auto; margin-left:auto" muted loop autoplay="true"></video>		
		</div>
		<div style="margin: auto; width: 49%; display:inline-block">
			<p style="font-size: 15px">Initial Angle = 35 degrees</p>
			<video src="assets/sPend35.mp4" style="width: 100%; margin-right: auto; margin-left:auto" loop muted autoplay="true"></video>
		</div>
	</div>
	<br>
	The red pendulum represents the less accurate model using the approximation and the blue is the the more accurate model. I added a plot on the top that shows you a comparasion of the theta versus time for each of the two simulations, as well showing the phase difference (how delayed the inaccurate model is at every moment in time).
	</p>
	<p>
	You can easily see how quickly the red pendulum goes out of phase when the initial angle is 35 degrees.
	</p>
	<h2>Two Coupled Pendulums</h2>
	<p>
	We can animate a system of two coupled pendulums in a similar way. We'll start with the equations of motion, 
	</p>
	<br>
	<img class="equation-center" src="http://latex.codecogs.com/svg.latex?\vec{z}=\begin{pmatrix}\theta\\\dot{\theta}\\\phi\\\dot{\phi}\end{pmatrix} \ \ \dot{\vec{z}}=\begin{pmatrix}\dot{\theta} \\ \ddot{\theta}\\ \dot{\phi} \\ \ddot{\phi}\\ \end{pmatrix}">
	<br>
	<p>Where theta is the angle of the left pendulum and phi is the angle of the right pendulum. We came up with relations for the coordinates in the <a href="#filler">derivations post</a>:</p><br>
	<img class="equation-center" src="http://latex.codecogs.com/svg.latex?\ddot{\theta} =\frac{\sin(\theta)(m_{1}(l_{1}\dot{\theta}^{2}-g)-kl_{1})kl_{2}\sin(\phi)}{m_{1}l_{1}\cos(\theta)}">
	<br>
	<img class="equation-center" src="http://latex.codecogs.com/svg.latex?\ddot{\phi} =  \frac{\sin(\phi)(m_{2}(l_{2}\dot{\phi}^{2}-g)-kl_{2})kl_{1}\sin(\theta)}{m_{2}l_{2}\cos(\phi)}">
	<br>
	<p>Then all we need to do is reformat the pendulum class to contain the new variables representing the second pendulum (L2, M2, spring constant k), and then insert the new equations into the equation function. The complete class ends up being:</p>
	<pre class="code-box2">

class coupledPendulum():

    def __init__(self,
                 g = 9.8,
                 L1 = 1.5,
                 L2 = 1.5,
                 M1 = 1.0,
                 M2 = 1.0,
                 k = 0.5):

        """initial state is (theta, thetaDot, phi, phiDot) in degrees
        where theta is the initial angle of the left pendulum, thetaDot is the initial speed
        of the left pendulum, and phi/phiDot is the same for the right pendulum"""
        self.init_state = [np.radians(25.0), 0, np.radians(0.0), 0]
        self.params = (L1, L2, M1, M2, g, k)
        self.time = np.arange(0, 50.0, 0.025)

    def equation(self, y0,t):

        (L1, L2, M1, M2, g, k) = self.params
        theta, thetaDot, phi, phiDot = y0

        dydx = [thetaDot,
                (sin(theta) * (M1 * (L1 * thetaDot * thetaDot - g) - k * L1) + k * L2 * sin(phi)) / (M1 * L1 * cos(theta)),
                phiDot,
                (sin(phi) * (M2 * (L2 * phiDot * phiDot - g) - k * L2) + k * L1 * sin(theta)) / (M2 * L2 * cos(phi))
                ]

        return dydx

    def solve_ODE(self):
        self.state = odeint(self.equation, self.init_state, self.time)

        """convert data into (x,y) coordinates"""
        x1 = sin(self.state[:, 0])*self.params[0]
        y1 = -1*cos(self.state[:, 0])*self.params[0]
        x2 = sin(self.state[:, 2])*self.params[1]
        y2 = -1*cos(self.state[:, 2])*self.params[1]
        return x1, y1, x2, y2
	</pre>
	<p>
	Likewise, we will need to rebuild the animation function. I added a third line to represent the spring that couples the two pendulums, and I added a text field for the tension in the string
	</p>
	<p>
	The tops of each pendulum are set at (-1, 0) and (1, 0) respectively, so we need to adjust the data as such in the animate function. The spring line is drawn between the two end points of the both pendulums.
	</p>
	<p>
	I calculated the tension in the string by calculating how much the spring was expanded or contracted from the equilibrium length, and multiplied it by the spring constant (Hooke's Law).
	</p>
	<br>
	<pre class="code-box2">
def animateCoupledPendulum(num,data2,line,line2, line3, line4, line5):

    """draw left pendulum, right pendulum, and the spring connecting them"""
    line.set_data([-1, data2[0, num] - 1], [0, data2[1, num]])
    line2.set_data([1, data2[2, num] + 1], [0, data2[3, num]])
    line3.set_data([data2[0, num] -1, data2[2, num] + 1], [data2[1, num], data2[3, num]])
   
   """xdata is the time used for the displacment plots, and ydata(1,2) is the angular displacements for these plots"""
    xdata.append(num/40.0)
    ydata1.append(np.degrees(np.arctan(data2[0,num]/data2[1,num])))
    ydata2.append(np.degrees(np.arctan(data2[2,num]/data2[3,num])))

    """plot the displacement plots"""
    line4.set_data(xdata, ydata1)
    line5.set_data(xdata, ydata2)
   
   """update spring tension text, time text"""
    theta_text.set_text('Spring Tension: ' + str(abs(round(coupPend.getSpringConstant()*(data2[2,num]-data2[0,num]),1))) + 'N')
    time_text.set_text('t= ' + str(round(num*0.025,1)) + 's')
    return line, line2, line3, line4, line5
	</pre>
	<br>
	<p>
	The animation object is essentially the same as the one used in the single pendulum simulation. If you want to see all of the code that I used in this post you can find it <a href="#code">here</a>
	<br>It's interesting to see how the energy transfers from pendulum to pendulum. One other thing I'd like to note is that the tension is calculated by ignoring any displacment in the y direction, i.e. this is not a 100% accurate model in that the forces exerted on the masses by the spring only have an x-component. 
	</p>
	<br>
	<div style="text-align:center">
		<video src="assets/cPend25.mp4" style="width: 65%; margin-right: auto; margin-left:auto" muted loop autoplay="true"></video>		
	</div>
	<br>	
	<br>
	<h2>Double Pendulum</h2>
	<p>
	Lastly, we have the double pendulum. Like with the coupled pendulum system, we have two generalized coordinates. One for the angular position of the upper leg of the pendulum, and one for the angular position of the lower leg of the pendulum. Theta will be used for the upper leg, and phi will be used for the lower leg. We will start by defining a first order system of equations from the basis vector z consisting of the states of the system, and from that create a system of first order equations that we can plug into the odeint function: 
	</p>
	<img class="equation-center" src="http://latex.codecogs.com/svg.latex?\vec{z}=\begin{pmatrix}\theta\\\dot{\theta}\\\phi\\\dot{\phi}\end{pmatrix} \ \ \dot{\vec{z}}=\begin{pmatrix}\dot{\theta} \\ \ddot{\theta}\\ \dot{\phi} \\ \ddot{\phi}\\ \end{pmatrix}">
	<br>	
	<p>
	<br>
	Again, we uncovered the equations for this first order system in <a href="#post">this post.</a>
	<p>
	The interesting thing about the double pendulum is that it, like other chaotic systems, i shighly sensitive to it's initial conditions. Below are two simulations of the double pendulum using the exact same physics and started at the exact same time. They the only difference between the two is a that the left simulation is released one degree higher than the right, and you can see what a difference it makes!
	</p>
	<br>
	<div style="margin:auto; text-align:center">
		<div style="margin: auto; width: 49%; display:inline-block">
			<p style="font-size: 10px">Initial State: (Theta = 120, ThetaDot = 0, Phi = 89, PhiDot = 0)</p>
			<video src="assets/dPend89.mp4" style="width: 100%; margin-right: auto; margin-left:auto" muted loop autoplay="true"></video>		
		</div>
		<div style="margin: auto; width: 49%; display:inline-block">
			<p style="font-size: 10px">Initial State: (Theta = 120, ThetaDot = 0, Phi = 90, PhiDot = 0)</p>
			<video src="assets/dpend90.mp4" style="width: 100%; margin-right: auto; margin-left:auto" loop muted autoplay="true"></video>
		</div>
	</div>
</div>

<div class="upper-footer">
  <div>
  <p style="font-family: 'Oswald', sans-serif; margin: 0">AROUND THE WEB</p>
  <a href="https://github.com/whitedann"><img class="botbutton" src="assets/github.svg"></a>
  <a href="https://www.linkedin.com/in/daniel-white-76434a66/"><img class="botbutton" src="assets/linkedin_circle.png"></a>
  </div>
</div>
<div class="lower-footer">
  <a style="text-decoration: none; color: white" href="index.html#home">top</a>
</div>

</body>

</html>
